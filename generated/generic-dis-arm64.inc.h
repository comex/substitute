/* Generated code; do not edit!
   generated by tables/gen.js from imaon2 '2b8112204067abe3d0643e23c2486656841ecafe'
   https://github.com/comex/imaon2
   arguments: '--gen-hook-disassembler --dis-pattern=P(XXX) out/out-AArch64.json'
   (fair warning: at present the main (Rust) code in that repository is barely
    started, embarrassingly so; no need to look at it ;p)
   In case it's copyrightable in any way, consider the generated code in the
   public domain.
*/

/* adrlabel_label_unk_Xd_1_ADR: ADR */
/* adrplabel_label_unk_Xd_1_ADRP: ADRP */
/* am_b_target_addr_B_1_B: B */
/* am_bl_target_addr_1_BL: BL */
/* am_brcond_target_B_5_Bcc: Bcc, CBNZW, CBNZX, CBZW, CBZX */
/* am_ldrlit_label_unk_Rt_6_LDRDl: LDRDl, LDRQl, LDRSWl, LDRSl, LDRWl, LDRXl */
/* GPR64_Rn_1_RET: RET */
/* am_tbrcond_target_B_4_TBNZW: TBNZW, TBNZX, TBZW, TBZX */
    switch ((op >> 26) & 0x1f) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 8:
    case 9:
    case 10:
    case 11:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 24:
    case 25:
    case 26:
    case 27:
    case 29:
    case 30:
    case 31:
        return P(unidentified)(ctx);
    case 4:
    case 12:
    case 20:
    case 28: {
        switch ((op >> 31) & 0x1) {
        case 0: {
            if ((op & 0x9f000000) == 0x10000000) {
                struct bitslice Xd = {.nruns = 1, .runs = (struct bitslice_run[]) {{0,0,5}}};
                struct bitslice label = {.nruns = 2, .runs = (struct bitslice_run[]) {{5,2,19}, {29,0,2}}};
                return P(adrlabel_label_unk_Xd_1_ADR)(ctx, Xd, label); /* 0x10000000 | 0x60ffffff */
            } else {
                return P(unidentified)(ctx);
            }
        }
        case 1: {
            if ((op & 0x9f000000) == 0x90000000) {
                struct bitslice Xd = {.nruns = 1, .runs = (struct bitslice_run[]) {{0,0,5}}};
                struct bitslice label = {.nruns = 2, .runs = (struct bitslice_run[]) {{5,2,19}, {29,0,2}}};
                return P(adrplabel_label_unk_Xd_1_ADRP)(ctx, Xd, label); /* 0x90000000 | 0x60ffffff */
            } else {
                return P(unidentified)(ctx);
            }
        }
        }
    }
    case 5: {
        switch ((op >> 31) & 0x1) {
        case 0: {
            struct bitslice addr = {.nruns = 1, .runs = (struct bitslice_run[]) {{0,0,26}}};
            return P(am_b_target_addr_B_1_B)(ctx, addr); /* 0x14000000 | 0x03ffffff */
        }
        case 1: {
            struct bitslice addr = {.nruns = 1, .runs = (struct bitslice_run[]) {{0,0,26}}};
            return P(am_bl_target_addr_1_BL)(ctx, addr); /* 0x94000000 | 0x03ffffff */
        }
        }
    }
    case 6:
    case 7: {
        switch ((op >> 31) & 0x1) {
        case 0: {
            if ((op & 0xbb000000) == 0x18000000) {
                insn_am_ldrlit_label_unk_Rt_6_LDRDl:;
                struct bitslice Rt = {.nruns = 1, .runs = (struct bitslice_run[]) {{0,0,5}}};
                struct bitslice label = {.nruns = 1, .runs = (struct bitslice_run[]) {{5,0,19}}};
                return P(am_ldrlit_label_unk_Rt_6_LDRDl)(ctx, Rt, label); /* 0x18000000 | 0x44ffffff */
            } else {
                return P(unidentified)(ctx);
            }
        }
        case 1: {
            if ((op & 0xfb000000) == 0x98000000) {
                goto insn_am_ldrlit_label_unk_Rt_6_LDRDl; /* 0x98000000 | 0x04ffffff */
            } else {
                return P(unidentified)(ctx);
            }
        }
        }
    }
    case 13: {
        switch ((op >> 25) & 0x1) {
        case 0: {
            insn_am_brcond_target_B_5_Bcc:;
            struct bitslice target = {.nruns = 1, .runs = (struct bitslice_run[]) {{5,0,19}}};
            return P(am_brcond_target_B_5_Bcc)(ctx, target); /* 0x34000000 | 0x81ffffff */
        }
        case 1: {
            struct bitslice target = {.nruns = 1, .runs = (struct bitslice_run[]) {{5,0,14}}};
            return P(am_tbrcond_target_B_4_TBNZW)(ctx, target); /* 0x36000000 | 0x81ffffff */
        }
        }
    }
    case 21: {
        switch ((op >> 25) & 0x1) {
        case 0: {
            if ((op & 0xff000010) == 0x54000000) {
                goto insn_am_brcond_target_B_5_Bcc; /* 0x54000000 | 0x00ffffef */
            } else {
                return P(unidentified)(ctx);
            }
        }
        case 1: {
            if ((op & 0xfffffc1f) == 0xd65f0000) {
                struct bitslice Rn = {.nruns = 1, .runs = (struct bitslice_run[]) {{5,0,5}}};
                return P(GPR64_Rn_1_RET)(ctx, Rn); /* 0xd65f0000 | 0x000003e0 */
            } else {
                return P(unidentified)(ctx);
            }
        }
        }
    }
    case 22:
    case 23: {
        if ((op & 0xbb000000) == 0x18000000) {
            goto insn_am_ldrlit_label_unk_Rt_6_LDRDl; /* 0x18000000 | 0x44ffffff */
        } else {
            return P(unidentified)(ctx);
        }
    }
    }
/*
static INLINE tdis_ret P(GPR64_Rn_1_RET)(struct bitslice ctx, struct bitslice Rn) {}
static INLINE tdis_ret P(adrlabel_label_unk_Xd_1_ADR)(struct bitslice ctx, struct bitslice Xd, struct bitslice label) {}
static INLINE tdis_ret P(adrplabel_label_unk_Xd_1_ADRP)(struct bitslice ctx, struct bitslice Xd, struct bitslice label) {}
static INLINE tdis_ret P(am_b_target_addr_B_1_B)(struct bitslice ctx, struct bitslice addr) {}
static INLINE tdis_ret P(am_bl_target_addr_1_BL)(struct bitslice ctx, struct bitslice addr) {}
static INLINE tdis_ret P(am_brcond_target_B_5_Bcc)(struct bitslice ctx, struct bitslice target) {}
static INLINE tdis_ret P(am_ldrlit_label_unk_Rt_6_LDRDl)(struct bitslice ctx, struct bitslice Rt, struct bitslice label) {}
static INLINE tdis_ret P(am_tbrcond_target_B_4_TBNZW)(struct bitslice ctx, struct bitslice target) {}
*/

